<Template Condition = "(function() --ease.xml
	xero()
	
	-- make a self-filling table based on a generator function
	local function cache(func)
		return setmetatable({}, {
			__index = function(self, k)
				self[k] = func(k)
				return self[k]
			end
		})
	end
	
	-- make a function cache its results from previous calls
	local function fncache(func, default)
		local cache = {}
		return function(arg)
			if arg == nil then arg = default end
			cache[arg] = cache[arg] or func(arg)
			return cache[arg]
		end
	end
	local function uncurry2(func)
		return function(a, b)
			func(a)(b)
		end
	end
	
	local sqrt = math.sqrt
	local sin = math.sin
	local cos = math.cos
	local pow = math.pow
	local exp = math.exp
	local pi = math.pi
	local abs = math.abs
	
	function flip(fn)
		return function(x) return 1 - fn(x) end
	end
	flip = fncache(flip)
	
	function bounce(t) return 4 * t * (1 - t) end
	function tri(t) return 1 - abs(2 * t - 1) end
	function bell(t) return inOutQuint(tri(t)) end
	function pop(t) return 3.5 * (1 - t) * (1 - t) * sqrt(t) end
	function tap(t) return 3.5 * t * t * sqrt(1 - t) end
	function pulse(t) return t < .5 and tap(t * 2) or -pop(t * 2 - 1) end
	
	function spike(t) return exp(-10 * abs(2 * t - 1)) end
	function inverse(t) return t * t * (1 - t) * (1 - t) / (0.5 - t) end
	
	popElastic = cache(function(damp)
		return cache(function(count)
			return function(t)
				return (1000 ^ -(t ^ damp) - 0.001) * sin(count * pi * t)
			end
		end)
	end)
	tapElastic = cache(function(damp)
		return cache(function(count)
			return function(t)
				return (1000 ^ -((1 - t) ^ damp) - 0.001) * sin(count * pi * (1 - t))
			end
		end)
	end)
	pulseElastic = cache(function(damp)
		return cache(function(count)
			local tap_e = tapElastic[damp][count]
			local pop_e = popElastic[damp][count]
			return function(t)
				return t > .5 and -pop_e(t * 2 - 1) or tap_e(t * 2)
			end
		end)
	end)
	
	impulse = cache(function(damp)
		return function(t)
			t = t ^ damp
			return t * (1000 ^ -t - 0.001) * 18.6
		end
	end)
	
	function instant() return 1 end
	function linear(t) return t end
	function inQuad(t) return t * t end
	function outQuad(t) return -t * (t - 2) end
	function inOutQuad(t)
		t = t * 2
		if t < 1 then
			return 0.5 * t ^ 2
		else
			return 1 - 0.5 * (2 - t) ^ 2
		end
	end
	function inCubic(t) return t * t * t end
	function outCubic(t) return 1 - (1 - t) ^ 3 end
	function inOutCubic(t)
		t = t * 2
		if t < 1 then
			return 0.5 * t ^ 3
		else
			return 1 - 0.5 * (2 - t) ^ 3
		end
	end
	function inQuart(t) return t * t * t * t end
	function outQuart(t) return 1 - (1 - t) ^ 4 end
	function inOutQuart(t)
		t = t * 2
		if t < 1 then
			return 0.5 * t ^ 4
		else
			return 1 - 0.5 * (2 - t) ^ 4
		end
	end
	function inQuint(t) return t ^ 5 end
	function outQuint(t) return 1 - (1 - t) ^ 5 end
	function inOutQuint(t)
		t = t * 2
		if t < 1 then
			return 0.5 * t ^ 5
		else
			return 1 - 0.5 * (2 - t) ^ 5
		end
	end
	function inExpo(t) return 1000 ^ (t - 1) - 0.001 end
	function outExpo(t) return 1.001 - 1000 ^ -t end
	function inOutExpo(t)
		t = t * 2
		if t < 1 then
			return 0.5 * 1000 ^ (t - 1) - 0.0005
		else
			return 1.0005 - 0.5 * 1000 ^ (1 - t)
		end
	end
	function inCirc(t) return 1 - sqrt(1 - t * t) end
	function outCirc(t) return sqrt(-t * t + 2 * t) end
	function inOutCirc(t)
		t = t * 2
		if t < 1 then
			return 0.5 - 0.5 * sqrt(1 - t * t)
		else
			t = t - 2
			return 0.5 + 0.5 * sqrt(1 - t * t)
		end
	end
	
	inElastic = function(a)
		local inner = function(p)
			return function(t)
				t = t - 1
				return -(a * pow(2, 10 * t) * sin(t - p / (2 * pi) * asin(1/a)) * (2 * pi) / p)
			end
		end
		return fncache(inner, 0.3)
	end
	inElastic = uncurry2(fncache(inElastic, 1))

	function outElastic(a)
		local inner = function(p)
			return function(t)
				return a * pow(2, 10 * t) * sin(t - p / (2 * pi) * asin(1/a)) * (2 * pi) / p + 1
			end
		end
		return fncache(inner, 0.3)
	end
	outElastic = uncurry2(fncache(outElastic, 1))

	function inOutElastic(a)
		local inner = function(p)
			local in1 = inElastic(a, p)
			local out1 = outElastic(a, p)
			return function(t) return t < 0.5 and in1(t * 2) * 0.5 or out1(t * 2 - 1) * 0.5 + 0.5 end
		end
		return fncache(inner, 0.3)
	end
	inOutElastic = uncurry2(fncache(inOutElastic, 1))
	
	function inBack(a) return function(t) return t * t * (a * t + t - a) end end
	inBack = fncache(inBack, 1.70158)

	function outBack(a) return function(t) t = t - 1 return t * t * (a * t + a) + 1 end end
	outBack = fncache(outBack, 1.70158)

	function inOutBack(s)
		local in1 = inBack(s)
		local out1 = outBack(s)
		return function(t) return t < 0.5 and in1(t * 2) * 0.5 or out1(t * 2 - 1) * 0.5 + 0.5 end
	end
	inOutBack = fncache(inOutBack, 1.70158)
	
	function outBounce(t)
		if t < 1 / 2.75 then
			return 7.5625 * t * t
		elseif t < 2 / 2.75 then
			t = t - 1.5 / 2.75
			return 7.5625 * t * t + 0.75
		elseif t < 2.5 / 2.75 then
			t = t - 2.25 / 2.75
			return 7.5625 * t * t + 0.9375
		else
			t = t - 2.625 / 2.75
			return 7.5625 * t * t + 0.984375
		end
	end
	function inBounce(t) return 1 - outBounce(1 - t) end
	function inOutBounce(t)
		if t < 0.5 then
			return inBounce(t * 2) * 0.5
		else
			return outBounce(t * 2 - 1) * 0.5 + 0.5
		end
	end
	
	function inSine(x)
		return 1 - cos(x * (pi * 0.5))
	end
	
	function outSine(x)
		return sin(x * (pi * 0.5))
	end
	
	function inOutSine(x)
		return 0.5 - 0.5 * cos(x * pi)
	end
	
end)()"/>
